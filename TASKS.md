Task 1: Remove Duplicate RLS Statements in schema.sql

Description: The schema.sql file contains duplicate alter table ... enable row level security statements, which can cause errors during migration. Consolidate these into a single statement per table.

Steps:





Open schema.sql.



Identify and remove duplicate RLS enabling statements for categories, clients, products, orders, and order_items.



Ensure each table has exactly one alter table ... enable row level security statement.



Verify the remaining statements are correctly formatted and include all tables.

Acceptance Criteria:





Each table (categories, clients, products, orders, order_items) has exactly one alter table ... enable row level security statement.



No syntax errors in schema.sql.



Running the schema in a fresh Supabase instance enables RLS on all specified tables without errors.

Definition of Done:





[x] Modified schema.sql with consolidated RLS statements.



[x] Tested schema application in a local Supabase instance using supabase db reset.











[x] No errors reported in Supabase logs during schema application.



Task 2: Tighten RLS Policies for Authenticated Access

Description: The current RLS policies (e.g., "Enable read access for all users") allow unauthenticated access to tables, posing a security risk. Update policies to restrict read access to authenticated users only.

Steps:





Open schema.sql.



Modify the following policies to include to authenticated:





"Enable read access for all users" for categories, clients, products, orders, and order_items.



Update the policy definitions to:

create policy "Enable read access for authenticated users" on public.categories
    for select to authenticated using (true);

Repeat for clients, products, orders, and order_items.



Test policies by attempting to query tables as an unauthenticated user and an authenticated user.

Acceptance Criteria:





All read policies (select) for categories, clients, products, orders, and order_items are restricted to authenticated users.



Unauthenticated users receive a 403 Forbidden error when querying these tables.



Authenticated users can query these tables successfully.



No syntax errors in policy definitions.

Definition of Done:





[x] Updated schema.sql with tightened RLS policies.



[x] Tested policies using Supabase’s SQL editor with authenticated and unauthenticated sessions.











[x] Verified no unauthorized access in Supabase logs.



Task 3: Enable UUID Extension in schema.sql

Description: The user_roles table uses uuid types, but the schema does not enable the uuid-ossp extension, which could cause deployment issues. Add the extension to the schema.

Steps:





Open schema.sql.



Add the following at the top of the file:

create extension if not exists "uuid-ossp";



Verify the user_roles table’s id and user_id columns use uuid types correctly.



Test the schema in a fresh Supabase instance to ensure the extension is loaded and UUIDs are generated.

Acceptance Criteria:





The uuid-ossp extension is enabled in schema.sql.



The user_roles table creates and uses UUIDs without errors.



Running the schema in a fresh Supabase instance does not throw extension-related errors.

Definition of Done:





[x] Added uuid-ossp extension to schema.sql.



[x] Tested schema in a local Supabase instance using supabase db reset.



[x] Verified UUID generation in user_roles table.











Task 4: Normalize Order Items Data

Description: The orders table stores order_items as a jsonb column, while a separate order_items table exists, leading to redundancy. Remove the jsonb column and rely on the order_items table.

Steps:





Open schema.sql.



Remove the order_items jsonb column from the orders table definition:

create table if not exists public.orders (
    id bigint generated by default as identity primary key,
    client_id bigint references public.clients(id),
    total decimal(10,2) not null,
    status text default 'Pendente',
    date date not null default current_date,
    created_at timestamp with time zone default timezone('utc'::text, now()) not null
);



Update all references to order_items in src/routes/orders/+page.svelte and related components to use the order_items table:





Modify fetchOrders to join with order_items:

async function fetchOrders() {
    const { data, error } = await supabase
        .from('orders')
        .select(`
            *,
            order_items (
                id,
                product_id,
                quantity,
                price
            )
        `)
        .order('date', { ascending: false });
    if (error) {
        console.error('Error fetching orders:', error);
        return;
    }
    allOrders = data.map(order => ({
        ...order,
        order_items: order.order_items || []
    }));
    loading = false;
}



Update handleSaveOrder to insert/update order_items separately:

async function handleSaveOrder(orderData: {
    id?: number;
    clientId: number;
    products: Array<{
        productId: number;
        quantity: number;
        price: number;
    }>;
    total: number;
    status: string;
    date: string;
}) {
    isProcessingSave = true;
    try {
        let orderId = orderData.id;
        if (orderData.id) {
            const { error } = await supabase
                .from('orders')
                .update({
                    client_id: orderData.clientId,
                    total: orderData.total,
                    status: orderData.status,
                    date: orderData.date
                })
                .eq('id', orderData.id);
            if (error) throw error;
            await supabase.from('order_items').delete().eq('order_id', orderData.id);
        } else {
            const { data, error } = await supabase
                .from('orders')
                .insert([{
                    client_id: orderData.clientId,
                    total: orderData.total,
                    status: orderData.status,
                    date: orderData.date
                }])
                .select('id')
                .single();
            if (error) throw error;
            orderId = data.id;
        }
        const orderItems = orderData.products.map(item => ({
            order_id: orderId,
            product_id: item.productId,
            quantity: item.quantity,
            price: item.price
        }));
        const { error: itemsError } = await supabase
            .from('order_items')
            .insert(orderItems);
        if (itemsError) throw itemsError;
        await fetchOrders();
        showOrderModal = false;
    } catch (error) {
        console.error('Error saving order:', error);
    } finally {
        isProcessingSave = false;
    }
}



Update OrderModal.svelte to handle order_items as a separate entity if necessary.



Test order creation, editing, and deletion to ensure data consistency.

Acceptance Criteria:





The orders table no longer has an order_items JSONB column.



Order items are stored exclusively in the order_items table.



Order creation, editing, and deletion work correctly, with items properly linked.



Realtime subscriptions reflect changes in both orders and order_items tables.

Definition of Done:





[x] Updated schema.sql to remove order_items JSONB column.



[x] Modified src/routes/orders/+page.svelte and related components to use order_items table.



[x] Tested order CRUD operations in a local Supabase instance.











Task 5: Consolidate Supabase Clients

Description: The codebase has two Supabase client definitions (src/lib/supabase.ts and src/lib/supabaseClient.ts), causing redundancy. Remove supabaseClient.ts and update all imports to use supabase.ts.

Steps:





Delete src/lib/supabaseClient.ts.



Search for all imports of supabaseClient in the codebase (e.g., import supabase from '$lib/supabaseClient').



Replace with import { supabase } from '$lib/supabase'.



Verify that all Supabase operations (e.g., auth, queries, subscriptions) function correctly.

Acceptance Criteria:





src/lib/supabaseClient.ts is deleted.



All Supabase client imports use src/lib/supabase.ts.



Authentication, data fetching, and subscriptions work as expected.

Definition of Done:





[x] Deleted src/lib/supabaseClient.ts.



[x] Updated all imports to use src/lib/supabase.ts.



[x] Tested authentication, queries, and subscriptions locally.











Task 6: Use SvelteKit Navigation in Auth Component

Description: The src/lib/components/Auth.svelte uses window.location.href for navigation, bypassing SvelteKit’s routing. Replace with SvelteKit’s goto function.

Steps:





Open src/lib/components/Auth.svelte.



Import goto from $app/navigation:

import { goto } from '$app/navigation';



Replace the window.location.href = '/orders' line in handleAuth with:

await goto('/orders', { replaceState: true });



Test sign-in and sign-up flows to ensure navigation works correctly.

Acceptance Criteria:





window.location.href is no longer used in Auth.svelte.



Sign-in redirects to /orders using goto.



Navigation history is not polluted (uses replaceState).



Sign-up flow still shows the confirmation message.

Definition of Done:





[x] Updated Auth.svelte to use goto.



[x] Tested sign-in and sign-up flows locally.











Task 7: Improve Session Handling in hooks.server.ts

Description: The src/hooks.server.ts constructs a session object with placeholder values, which may not reflect Supabase’s session data. Update to use Supabase’s actual session.

Steps:





Open src/hooks.server.ts.



Modify the getSession function to use Supabase’s getSession:

event.locals.getSession = async () => {
    const { data: { session } } = await event.locals.supabase.auth.getSession();
    return session;
};



Update the authorization handle to handle null sessions correctly:

const authorization: Handle = async ({ event, resolve }) => {
    const session = await event.locals.getSession();
    const path = event.url.pathname;
    const publicRoutes = ['/auth', '/auth/callback'];
    const isPublicRoute = publicRoutes.some(route => path.startsWith(route));
    if (!session && !isPublicRoute) {
        throw redirect(303, '/auth');
    }
    if (session && path.startsWith('/auth')) {
        throw redirect(303, '/orders');
    }
    if (session && path === '/') {
        throw redirect(303, '/orders');
    }
    if (session && routePermissions[path]) {
        const { data: userData } = await event.locals.supabase
            .from('user_roles')
            .select('role')
            .eq('user_id', session.user.id)
            .single();
        const userRole = userData?.role || 'user';
        session.user.user_metadata = { ...session.user.user_metadata, role: userRole };
        if (!session.user.user_metadata.role) {
            await event.locals.supabase.auth.updateUser({
                data: { role: userRole }
            });
        }
        const requiredPermission = routePermissions[path];
        if (!hasPermission(session.user, requiredPermission)) {
            throw error(403, {
                message: `Acesso negado: Você não tem permissão para ${requiredPermission.action} em ${requiredPermission.resource}`
            });
        }
    }
    return resolve(event);
};



Test authentication flows to ensure sessions are handled correctly.

Acceptance Criteria:





getSession returns Supabase’s actual session object or null.



Authorization logic handles null sessions correctly.



Role-based permissions are applied as before.



Authentication flows (sign-in, sign-up, sign-out) work without errors.

Definition of Done:





[x] Updated src/hooks.server.ts with improved session handling.



[x] Tested authentication flows locally.











Task 8: Add Error Boundaries to Pages

Description: Pages like src/routes/orders/+page.svelte lack error boundaries, risking application crashes. Add +error.svelte files to handle errors gracefully.

Steps:





Create src/routes/orders/+error.svelte:

<script>
    import { page } from '$app/stores';
</script>
<div class="alert alert-error">
    <h1>Error: {$page.error.message}</h1>
    <p>Please try again later or contact support.</p>
    <a href="/orders" class="btn btn-primary">Retry</a>
</div>



Create similar +error.svelte files for src/routes/products, src/routes/clients, and src/routes/categories.



Test error handling by simulating a Supabase query failure (e.g., invalid table name).

Acceptance Criteria:





Each route (orders, products, clients, categories) has a corresponding +error.svelte file.



Errors are displayed to the user with a retry option.



The application does not crash on query failures.

Definition of Done:





[x] Created +error.svelte files for specified routes.



[x] Tested error handling with simulated failures.











Task 9: Move daisyUI Theme to tailwind.config.js

Description: The silk theme is defined in src/style.css using @plugin "daisyui/theme", which is unconventional. Move it to tailwind.config.js.

Steps:





Open tailwind.config.js (or create if missing).



Add the silk theme under daisyui.themes:

/** @type {import('tailwindcss').Config} */
export default {
    content: ['./src/**/*.{html,js,svelte,ts}'],
    theme: {
        extend: {},
    },
    plugins: [
        require('daisyui'),
    ],
    daisyui: {
        themes: [
            {
                silk: {
                    'base-100': 'oklch(97% 0.0035 67.78)',
                    'base-200': 'oklch(95% 0.0081 61.42)',
                    'base-300': 'oklch(90% 0.0081 61.42)',
                    'base-content': 'oklch(40% 0.0081 61.42)',
                    'primary': 'oklch(23.27% 0.0249 284.3)',
                    'primary-content': 'oklch(80% 0.0081 61.42)',
                    'secondary': 'oklch(23.27% 0.0249 284.3)',
                    'secondary-content': 'oklch(73.92% 0.2135 50.94)',
                    'accent': 'oklch(23.27% 0.0249 284.3)',
                    'accent-content': 'oklch(88.92% 0.2061 189.9)',
                    'neutral': 'oklch(20% 0 0)',
                    'neutral-content': 'oklch(80% 0.0081 61.42)',
                    'info': 'oklch(80.39% 0.1148 241.68)',
                    'info-content': 'oklch(30.39% 0.1148 241.68)',
                    'success': 'oklch(83.92% 0.0901 136.87)',
                    'success-content': 'oklch(23.92% 0.0901 136.87)',
                    'warning': 'oklch(83.92% 0.1085 80)',
                    'warning-content': 'oklch(43.92% 0.1085 80)',
                    'error': 'oklch(75.1% 0.1814 22.37)',
                    'error-content': 'oklch(35.1% 0.1814 22.37)',
                },
            },
        ],
    },
};



Open src/style.css and remove the @plugin "daisyui/theme" section.



Verify the theme is applied correctly by checking UI elements (e.g., buttons, cards) for consistent styling.

Acceptance Criteria:





The silk theme is defined in tailwind.config.js.



src/style.css no longer contains the @plugin "daisyui/theme" section.



UI elements retain the same appearance as before.

Definition of Done:





[ ] Updated tailwind.config.js with silk theme.



[ ] Removed theme from src/style.css.



[ ] Tested UI rendering locally.











Task 10: Standardize Tailwind and daisyUI Class Usage

Description: The codebase mixes Tailwind utility classes and daisyUI components inconsistently. Document a convention and apply it to src/lib/components/Auth.svelte.

Steps:





Create a STYLE_GUIDE.md file in the project root:

# Style Guide
- **daisyUI Components**: Use for buttons (`btn`), cards (`card`), alerts (`alert`), modals (`modal`), and tables (`table`).
- **Tailwind Utilities**: Use for layout (e.g., `flex`, `grid`), spacing (e.g., `m-4`, `p-2`), and custom styling not covered by daisyUI.
- **Consistency**: Apply daisyUI classes first, followed by Tailwind utilities for overrides (e.g., `btn btn-primary w-full`).



Open src/lib/components/Auth.svelte.



Update classes to follow the convention:





Replace w-full max-w-md with card w-full max-w-md for the main container.



Ensure buttons use btn and appropriate variants (e.g., btn btn-primary, btn btn-outline).



Test the component to ensure visual consistency.

Acceptance Criteria:





STYLE_GUIDE.md exists and documents class usage.



Auth.svelte uses daisyUI components for buttons and cards, with Tailwind utilities for layout/spacing.



The component’s appearance is unchanged or improved.

Definition of Done:





[ ] Created STYLE_GUIDE.md.



[ ] Updated Auth.svelte classes.



[ ] Tested component rendering locally.











Task 11: Use Tailwind Theme Colors in chartConfig.ts

Description: The src/lib/chartConfig.ts hardcodes color values instead of using Tailwind’s theme. Update to reference theme colors.

Steps:





Open src/lib/chartConfig.ts.



Update the colors object to use Tailwind theme values:

import resolveConfig from 'tailwindcss/resolveConfig';
import tailwindConfig from '../../tailwind.config.js';
const { theme } = resolveConfig(tailwindConfig);
export const colors = {
    primary: theme.colors.primary,
    success: theme.colors.success,
    warning: theme.colors.warning,
    error: theme.colors.error,
    info: theme.colors.info,
    base100: theme.colors['base-100'],
    base200: theme.colors['base-200'],
    base300: theme.colors['base-300'],
    baseContent: theme.colors['base-content']
};



Ensure tailwind.config.js exports the config correctly:

module.exports = {
    // ... existing config
};



Test charts to ensure colors match the silk theme.

Acceptance Criteria:





chartConfig.ts uses Tailwind theme colors.



Charts render with the same colors as defined in tailwind.config.js.



No runtime errors from invalid theme references.

Definition of Done:





[ ] Updated chartConfig.ts to use theme colors.



[ ] Tested chart rendering locally.











Task 12: Use daisyUI Modal for ProductModal

Description: The ProductModal component is custom-built. Replace it with daisyUI’s modal component to reduce code.

Steps:





Open src/lib/components/ProductModal.svelte.



Refactor to use daisyUI’s modal:

<script lang="ts">
    export let showModal: boolean;
    export let products: Array<any>;
    export let product: any;
    export let onSave: (data: any) => void;
    export let isProcessing: boolean;
    let formData = product ? { ...product } : { name: '', price: 0, stock: 0, category: '' };
    function handleSubmit() {
        onSave(formData);
    }
</script>
<div class="modal" class:modal-open={showModal}>
    <div class="modal-box">
        <h3 class="font-bold text-lg">{product ? 'Edit Product' : 'Add Product'}</h3>
        <form on:submit|preventDefault={handleSubmit} class="space-y-4">
            <div class="form-control">
                <label class="label"><span class="label-text">Name</span></label>
                <input type="text" bind:value={formData.name} class="input input-bordered" required />
            </div>
            <div class="form-control">
                <label class="label"><span class="label-text">Price</span></label>
                <input type="number" bind:value={formData.price} class="input input-bordered" required />
            </div>
            <div class="form-control">
                <label class="label"><span class="label-text">Stock</span></label>
                <input type="number" bind:value={formData.stock} class="input input-bordered" required />
            </div>
            <div class="form-control">
                <label class="label"><span class="label-text">Category</span></label>
                <input type="text" bind:value={formData.category} class="input input-bordered" required />
            </div>
        </form>
        <div class="modal-action">
            <button class="btn" on:click={() => showModal = false} disabled={isProcessing}>Cancel</button>
            <button class="btn btn-primary" on:click={handleSubmit} disabled={isProcessing}>
                {#if isProcessing}<span class="loading loading-spinner"></span>{/if}
                Save
            </button>
        </div>
    </div>
</div>



Test the modal for adding and editing products.

Acceptance Criteria:





ProductModal.svelte uses daisyUI’s modal component.



Add and edit product flows work as before.



Modal is accessible and responsive.

Definition of Done:





[ ] Refactored ProductModal.svelte to use daisyUI modal.



[ ] Tested add/edit product flows locally.











Task 13: Use daisyUI Modal for OrderModal and ClientModal

Description: Similar to ProductModal, refactor OrderModal and ClientModal to use daisyUI’s modal component.

Steps:





Open src/lib/components/OrderModal.svelte and src/lib/components/ClientModal.svelte.



Refactor each to use daisyUI’s modal, following the pattern from Task 12.



Update form handling and bindings to match existing functionality.



Test add/edit flows for orders and clients.

Acceptance Criteria:





OrderModal.svelte and ClientModal.svelte use daisyUI’s modal component.



Add and edit flows for orders and clients work as before.



Modals are accessible and responsive.

Definition of Done:





[ ] Refactored OrderModal.svelte and ClientModal.svelte to use daisyUI modal.



[ ] Tested add/edit flows locally.











Task 14: Remove Duplicate Brand Components

Description: The codebase has Brand.svelte and brand_temp.svelte with similar SVG content. Consolidate into a single component with a parameterized fill color.

Steps:





Open src/lib/components/Brand.svelte.



Add a fill prop:

<script>
    export let fill = '#4c4647';
</script>
<svg ...>
    <path ... fill={fill} />
    <path ... fill={fill} />
    <path ... fill={fill} />
</svg>



Delete src/lib/components/brand_temp.svelte.



Search for references to brand_temp and update to use Brand with appropriate fill colors.



Test components using the Brand component to ensure correct rendering.

Acceptance Criteria:





brand_temp.svelte is deleted.



Brand.svelte accepts a fill prop.



All references to brand_temp are updated to use Brand.



SVG renders correctly with different fill colors.

Definition of Done:





[ ] Updated Brand.svelte with fill prop.



[ ] Deleted brand_temp.svelte.



[ ] Updated references to use Brand.



[ ] Tested SVG rendering locally.











Task 15: Create Generic Modal Component

Description: Modal components share similar logic. Create a GenericModal component to reduce duplication and refactor ProductModal, OrderModal, and ClientModal to use it.

Steps:





Create src/lib/components/GenericModal.svelte:

<script lang="ts">
    export let showModal: boolean;
    export let title: string;
    export let onSave: () => void;
    export let onCancel: () => void;
    export let isProcessing: boolean = false;
</script>
<div class="modal" class:modal-open={showModal}>
    <div class="modal-box">
        <h3 class="font-bold text-lg">{title}</h3>
        <slot />
        <div class="modal-action">
            <button class="btn" on:click={onCancel} disabled={isProcessing}>Cancel</button>
            <button class="btn btn-primary" on:click={onSave} disabled={isProcessing}>
                {#if isProcessing}<span class="loading loading-spinner"></span>{/if}
                Save
            </button>
        </div>
    </div>
</div>



Refactor ProductModal.svelte to use GenericModal:

<script lang="ts">
    export let showModal: boolean;
    export let products: Array<any>;
    export let product: any;
    export let onSave: (data: any) => void;
    export let isProcessing: boolean;
    let formData = product ? { ...product } : { name: '', price: 0, stock: 0, category: '' };
    function handleSubmit() {
        onSave(formData);
    }
</script>
<GenericModal
    {showModal}
    title={product ? 'Edit Product' : 'Add Product'}
    onSave={handleSubmit}
    onCancel={() => showModal = false}
    {isProcessing}
>
    <form on:submit|preventDefault={handleSubmit} class="space-y-4">
        <div class="form-control">
            <label class="label"><span class="label-text">Name</span></label>
            <input type="text" bind:value={formData.name} class="input input-bordered" required />
        </div>
        <div class="form-control">
            <label class="label"><span class="label-text">Price</span></label>
            <input type="number" bind:value={formData.price} class="input input-bordered" required />
        </div>
        <div class="form-control">
            <label class="label"><span class="label-text">Stock</span></label>
            <input type="number" bind:value={formData.stock} class="input input-bordered" required />
        </div>
        <div class="form-control">
            <label class="label"><span class="label-text">Category</span></label>
            <input type="text" bind:value={formData.category} class="input input-bordered" required />
        </div>
    </form>
</GenericModal>



Refactor OrderModal.svelte and ClientModal.svelte similarly.



Test all modals to ensure functionality is unchanged.

Acceptance Criteria:





GenericModal.svelte exists and handles common modal logic.



ProductModal, OrderModal, and ClientModal use GenericModal.



Add/edit flows for products, orders, and clients work as before.



Modals are accessible and responsive.

Definition of Done:





[ ] Created GenericModal.svelte.



[ ] Refactored ProductModal, OrderModal, and ClientModal.



[ ] Tested add/edit flows locally.











Task 16: Complete Migration Setup

Description: The supabase/migrations/20250507201004_remote_schema.sql file is empty. Populate it with the schema.sql content to ensure proper database versioning.

Steps:





Open supabase/migrations/20250507201004_remote_schema.sql.



Copy the contents of schema.sql (after applying Tasks 1-4) into the migration file.



Verify the migration applies correctly using supabase db push.



Update README.md to include migration instructions:

## Database Migrations
To apply migrations:
```bash
supabase db push



Acceptance Criteria:





20250507201004_remote_schema.sql contains the full schema.



Migration applies without errors in a fresh Supabase instance.



README.md includes migration instructions.

Definition of Done:





[ ] Populated 20250507201004_remote_schema.sql.



[ ] Tested migration with supabase db push.



[ ] Updated README.md.











Task 17: Implement Pagination for Orders

Description: The orders page fetches all orders without pagination, which could impact performance. Implement pagination using Supabase’s range method.

Steps:





Open src/routes/orders/+page.svelte.



Add pagination state and controls:

<script lang="ts">
    let page = 1;
    let pageSize = 10;
    let totalOrders = 0;
    async function fetchOrders(page: number, pageSize: number) {
        const { data, error, count } = await supabase
            .from('orders')
            .select('*', { count: 'exact' })
            .order('date', { ascending: false })
            .range((page - 1) * pageSize, page * pageSize - 1);
        if (error) {
            console.error('Error fetching orders:', error);
            return;
        }
        allOrders = data;
        totalOrders = count || 0;
        loading = false;
    }
    function changePage(newPage: number) {
        page = newPage;
        fetchOrders(page, pageSize);
    }
</script>
<div class="card bg-base-100 card-border border-base-300">
    <div class="card-body">
        <!-- Existing content -->
        <div class="flex justify-between mt-4">
            <button
                class="btn"
                on:click={() => changePage(page - 1)}
                disabled={page === 1}
            >Previous</button>
            <span>Page {page} of {Math.ceil(totalOrders / pageSize)}</span>
            <button
                class="btn"
                on:click={() => changePage(page + 1)}
                disabled={page * pageSize >= totalOrders}
            >Next</button>
        </div>
    </div>
</div>



Update onMount to call fetchOrders(page, pageSize).



Test pagination with a large dataset (e.g., insert 50 orders).

Acceptance Criteria:





Orders are fetched in pages of 10.



Pagination controls allow navigating between pages.



Total page count is displayed correctly.



Performance is improved for large datasets.

Definition of Done:





[ ] Updated orders/+page.svelte with pagination.



[ ] Tested with a large dataset locally.











Task 18: Implement Pagination for Products and Clients

Description: Similar to orders, implement pagination for products and clients pages.

Steps:





Open src/routes/products/+page.svelte and src/routes/clients/+page.svelte.



Apply the same pagination logic as Task 17, updating fetchProducts and fetchClients to use range and adding pagination controls.



Test pagination with large datasets for both tables.

Acceptance Criteria:





Products and clients are fetched in pages of 10.



Pagination controls work as expected.



Total page count is displayed correctly.

Definition of Done:





[ ] Updated products/+page.svelte and clients/+page.svelte with pagination.



[ ] Tested with large datasets locally.











Task 19: Optimize Realtime Subscriptions

Description: Realtime subscriptions refetch all data on every change, which is inefficient. Handle specific events (INSERT, UPDATE, DELETE) to update the state incrementally.

Steps:





Open src/routes/orders/+page.svelte.



Update the subscription to handle specific events:

onMount(() => {
    fetchOrders(page, pageSize);
    const subscription = supabase
        .channel('orders_changes')
        .on('postgres_changes', { event: 'INSERT', schema: 'public', table: 'orders' }, (payload) => {
            allOrders = [payload.new, ...allOrders].slice(0, pageSize);
            totalOrders += 1;
        })
        .on('postgres_changes', { event: 'UPDATE', schema: 'public', table: 'orders' }, (payload) => {
            allOrders = allOrders.map((o) => (o.id === payload.new.id ? payload.new : o));
        })
        .on('postgres_changes', { event: 'DELETE', schema: 'public', table: 'orders' }, (payload) => {
            allOrders = allOrders.filter((o) => o.id !== payload.old.id);
            totalOrders -= 1;
        })
        .subscribe();
    return () => {
        subscription.unsubscribe();
    };
});



Apply similar changes to src/routes/products/+page.svelte and src/routes/clients/+page.svelte.



Test subscriptions by inserting, updating, and deleting records.

Acceptance Criteria:





Subscriptions handle INSERT, UPDATE, and DELETE events incrementally.



Full data refetches are eliminated.



UI updates correctly in real-time.

Definition of Done:





[ ] Updated subscriptions in orders, products, and clients pages.



[ ] Tested realtime updates locally.











Summary

These 19 tasks address all recommendations from the Codebase Analysis Report, covering Supabase, Svelte/SvelteKit, Tailwind CSS, daisyUI, and general code quality improvements. Each task is designed to be specific, testable, and aligned with project rules, ensuring the OMS becomes more secure, maintainable, and performant.
